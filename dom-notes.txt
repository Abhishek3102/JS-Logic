
 1. Selecting Elements
 `getElementById(id)`: Selects an element using its `id` and allows modifications.  
 `getElementsByClassName(className)`: Selects multiple elements with a specific class (returns HTMLCollection).  
 `getElementsByTagName(tagName)`: Selects all elements of a specific tag (e.g., all `<p>` elements).  
 `querySelector(selector)`: Selects the first matching element using a CSS selector.  
 `querySelectorAll(selector)`: Selects all matching elements using a CSS selector (returns a NodeList).  



 2. Modifying DOM Elements
 `innerText`: Changes the text content of an element.  
 `innerHTML`: Updates the HTML inside an element, allowing new elements to be added.  
 `style.property`: Modifies CSS properties of an element (e.g., color, background, border).  



 3. Creating & Appending Elements
 `document.createElement(tag)`: Creates a new element dynamically.  
 `appendChild(element)`: Adds a new element to the end of a parent element.  
 `append(element)`: Similar to `appendChild`, but allows adding text or multiple elements.  
 `insertBefore(newElement, referenceElement)`: Inserts an element before another existing element.  



 4. Removing Elements
 `remove()`: Directly removes an element from the DOM.  
 `removeChild(childElement)`: Removes a specific child element from its parent.  



 5. Event Handling
 `addEventListener(event, callback)`: Attaches an event (like `click`, `mouseover`, etc.) to an element.  
 `mouseover` & `mouseout`: Detects when the mouse enters and leaves an element.  
 `keydown`: Captures keyboard input when a key is pressed.  



 6. Form Handling
 `value`: Retrieves or updates the input field's value.  
 `preventDefault()`: Stops the default form submission (prevents page reload).  
 `trim()`: Removes unnecessary spaces from user input to validate empty fields.  



 7. Class Manipulation (`classList`)
 `add(className)`: Adds a new CSS class to an element.  
 `remove(className)`: Removes a CSS class from an element.  
 `toggle(className)`: Adds the class if missing, otherwise removes it.  



 8. Window Methods
 `setTimeout(callback, delay)`: Runs a function after a specific time (milliseconds).  
 `setInterval(callback, interval)`: Repeats a function at fixed intervals until stopped.  
 `clearInterval(intervalID)`: Stops a repeating interval process.  



 9. Local Storage & Session Storage
 `localStorage.setItem(key, value)`: Stores data permanently in the browser.  
 `localStorage.getItem(key)`: Retrieves stored data from local storage.  
 `sessionStorage.setItem(key, value)`: Stores data only for the session (lost when the tab is closed).  



 10. Fetch API (AJAX)
 `fetch(url)`: Fetches data from an API asynchronously.  
 `.then(response => response.json())`: Converts the response into JSON format.  
 `.catch(error)`: Handles any errors that occur during the fetch request.  
 `async function() {}`: Defines an asynchronous function.  
 `await fetch(url)`: Waits for the API response before proceeding.  



 11. Changing Attributes
 `setAttribute(attr, value)`: Changes an element‚Äôs attribute (e.g., updating a link‚Äôs `href`).  
 `getAttribute(attr)`: Retrieves the current value of an attribute.  



 12. Scroll Events
 `window.addEventListener("scroll", callback)`: Detects when the user scrolls the page.  

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

differnce between innertext and textcontent
The difference between `innerText` and `textContent` in HTML (JavaScript DOM) lies mainly in how they handle **whitespace**, **hidden elements**, and **performance**. Here's a breakdown:

---

### üîπ `textContent`

* Returns the **raw text** of an element and all its descendants.
* Preserves **all text**, including that from hidden elements (e.g., elements with `display: none`).
* Faster, because it **doesn't trigger reflow or style calculation**.
* Preserves **line breaks**, but ignores styles like CSS `display: none`.

‚úÖ **Use when you want all the text exactly as it is in the DOM**, regardless of visibility or styling.

```html
<div id="example">
  Hello <span style="display: none">World</span>
</div>

<script>
  console.log(document.getElementById("example").textContent); 
  // Output: "Hello World"
</script>
```

---

### üîπ `innerText`

* Returns the **rendered text**, i.e., what's actually visible to the user.
* Ignores text from elements that are **hidden via CSS** (`display: none`, `visibility: hidden`, etc.).
* Takes CSS styles into account (like line breaks).
* Slower, because it **triggers layout and style recalculation**.

‚úÖ **Use when you want to extract only the visible, user-facing text**.

```html
<div id="example">
  Hello <span style="display: none">World</span>
</div>

<script>
  console.log(document.getElementById("example").innerText); 
  // Output: "Hello"
</script>
```

---

### Summary Table

| Feature               | `textContent`    | `innerText`           |
| --------------------- | ---------------- | --------------------- |
| Includes hidden text? | ‚úÖ Yes            | ‚ùå No                  |
| Triggers reflow?      | ‚ùå No             | ‚úÖ Yes                 |
| Performance           | üü¢ Faster        | üî¥ Slower             |
| Preserves formatting? | ‚ùå No             | ‚úÖ Yes (visible only)  |
| Use case              | Get all raw text | Get only visible text |

-------------------------------------------------------------------------------------------

The difference between **HTMLCollection** and **NodeList** in the DOM API mainly revolves around **what they contain**, **how they're accessed**, and **how dynamic they are**.

---

### üîπ HTMLCollection

* **Live** collection: updates automatically if the DOM changes.
* Contains only **Element nodes** (no text nodes, comments, etc.).
* Returned by methods like:

  * `document.getElementsByTagName()`
  * `document.getElementsByClassName()`
  * `element.children`

```js
const divs = document.getElementsByTagName('div'); // HTMLCollection
```

---

### üîπ NodeList

* Can be **live** or **static**:

  * **Live**: `Node.childNodes`
  * **Static**: `querySelectorAll()`
* Can contain any **Node** type: elements, text nodes, comments, etc.
* Returned by methods like:

  * `document.querySelectorAll()` (static)
  * `Node.childNodes` (live)

```js
const divs = document.querySelectorAll('div'); // NodeList (static)
```

---

### üîÅ Live vs Static Example

```html
<ul id="list">
  <li>Item 1</li>
</ul>

<script>
  const htmlCollection = document.getElementsByTagName('li');
  const nodeList = document.querySelectorAll('li');

  const ul = document.getElementById('list');
  const newLi = document.createElement('li');
  newLi.textContent = 'Item 2';
  ul.appendChild(newLi);

  console.log(htmlCollection.length); // 2 (live)
  console.log(nodeList.length);       // 1 (static)
</script>
```

---

### üßæ Summary Table

| Feature          | HTMLCollection          | NodeList                           |
| ---------------- | ----------------------- | ---------------------------------- |
| Live or static   | ‚úÖ Live                  | ‚ùóBoth (depends on method)          |
| Contents         | Element nodes only      | All node types                     |
| Indexable        | ‚úÖ Yes (like array)      | ‚úÖ Yes                              |
| Array methods?   | ‚ùå No (needs conversion) | ‚ùå Usually no (unless `forEach`)    |
| Common use cases | `getElementsBy*()`      | `querySelectorAll()`, `childNodes` |

---

### üîÅ Convert to real array (if needed)

```js
const arrFromHTML = Array.from(htmlCollection);
const arrFromNodeList = [...nodeList];
```

Let me know if you want a visual DOM example or a real-world use case!
